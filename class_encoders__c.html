<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TB PHASE: Encoders_c Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TB PHASE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_encoders__c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_encoders__c-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Encoders_c Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd3d73a67dd63521f7395e6a9716b47a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoders__c.html#afd3d73a67dd63521f7395e6a9716b47a">Encoders_c</a> ()</td></tr>
<tr class="separator:afd3d73a67dd63521f7395e6a9716b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b4ed0ada44d60cbc7559d1188dc13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoders__c.html#a97b4ed0ada44d60cbc7559d1188dc13d">ISR</a> (INT6_vect)</td></tr>
<tr class="separator:a97b4ed0ada44d60cbc7559d1188dc13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59863f4c577172e749340dcc5b2e9b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoders__c.html#ac59863f4c577172e749340dcc5b2e9b2">ISR</a> (PCINT0_vect)</td></tr>
<tr class="separator:ac59863f4c577172e749340dcc5b2e9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d216ae20740fa2b44a766cde21662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoders__c.html#aa09d216ae20740fa2b44a766cde21662">setupEncoder0</a> ()</td></tr>
<tr class="separator:aa09d216ae20740fa2b44a766cde21662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655e28b0ab1578b6bd258c87d2330716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_encoders__c.html#a655e28b0ab1578b6bd258c87d2330716">setupEncoder1</a> ()</td></tr>
<tr class="separator:a655e28b0ab1578b6bd258c87d2330716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd3d73a67dd63521f7395e6a9716b47a" name="afd3d73a67dd63521f7395e6a9716b47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3d73a67dd63521f7395e6a9716b47a">&#9670;&nbsp;</a></span>Encoders_c()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Encoders_c::Encoders_c </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor for encoders class</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a97b4ed0ada44d60cbc7559d1188dc13d" name="a97b4ed0ada44d60cbc7559d1188dc13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4ed0ada44d60cbc7559d1188dc13d">&#9670;&nbsp;</a></span>ISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Encoders_c::ISR </td>
          <td>(</td>
          <td class="paramtype">INT6_vect&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This ISR (Interrupt Service Routine) handles just Encoder 0. Interrupt is triggered by change of state of the motor's quadrature encoder. The quadrature encoder has two channels, A and B which may both have states 0 and 1. ISR to read the Encoder0 Channel A and B pins and then look up based on transition what kind of motor rotation must have occured.</p>
<p >The ISR is only called when a pin changes. Only one pin may change at a time. The XOR(AB) signal change from "Channel A" triggers ISR.</p>
<p >Firstly, the ISR reads the new state of the encoder pins: </p><pre class="fragment">    boolean e0_B = digitalRead( ENCODER_0_B_PIN ); // normal B state
    boolean e0_A = digitalRead( ENCODER_0_A_PIN ); // XOR(AB)
</pre><p> A software XOR (^) operation logically infers the true value of A given the state of B </p><pre class="fragment">    e0_A = e0_A ^ e0_B;
</pre><p >Bitpack the new and old encoder values into a 4 bit binary in the format:</p>
<p >State: new B new A old B old A</p>
<p >State: (bit3) (bit2) (bit1) (bit0) </p><pre class="fragment">    state_e0 = state_e0 | ( e0_B  &lt;&lt; 3 );
    state_e0 = state_e0 | ( e0_A  &lt;&lt; 2 );
</pre><p> Perform a case match on the value of this 4 bit number to determine if the motor has moved forward or backwards.</p>
<p >Once this had been determined, clear the register.</p>
<p >Increment or decrement a volatile encoder count value based on movement.</p>
<p >NOTE: It takes 358 interrupts for a full rotation of the wheel (gearbox reduction * stator rotations)</p>

</div>
</div>
<a id="ac59863f4c577172e749340dcc5b2e9b2" name="ac59863f4c577172e749340dcc5b2e9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59863f4c577172e749340dcc5b2e9b2">&#9670;&nbsp;</a></span>ISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Encoders_c::ISR </td>
          <td>(</td>
          <td class="paramtype">PCINT0_vect&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This ISR handles just Encoder 1, see above <a class="el" href="class_encoders__c.html#a97b4ed0ada44d60cbc7559d1188dc13d">ISR()</a> definition and description.</p>

</div>
</div>
<a id="aa09d216ae20740fa2b44a766cde21662" name="aa09d216ae20740fa2b44a766cde21662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09d216ae20740fa2b44a766cde21662">&#9670;&nbsp;</a></span>setupEncoder0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Encoders_c::setupEncoder0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >setupEncoder0 must be called before encoder 0 can be accessed (or nothing wil happen!). Function sets up encoder 0 for operation through the following actions:</p>
<p >Setup pins for encoder 0</p>
<pre class="fragment">      pinMode( ENCODER_0_A_PIN, INPUT );
      pinMode( ENCODER_0_B_PIN, INPUT );
</pre><p >Initialise the recorded state of e0 encoder. </p><pre class="fragment">      state_e0 = 0;
</pre><p> Get initial state of encoder pins A + B</p>
<pre class="fragment">      boolean e0_A = digitalRead( ENCODER_0_A_PIN );
      boolean e0_B = digitalRead( ENCODER_0_B_PIN );
      e0_A = e0_A ^ e0_B;
</pre><p> Set up PE6 as an external interupt (INT6), which means it can have its own dedicated ISR vector INT6_vector. Disable external interrupts for INT6 first.</p>
<p >Set INT6 bit low, preserve other bits </p><pre class="fragment">     EIMSK = EIMSK &amp; ~(1&lt;&lt;INT6);
     EICRB |= ( 1 &lt;&lt; ISC60 );
     EIFR |= ( 1 &lt;&lt; INTF6 );
</pre><p >Once INT6 interrupt is set up, enable the interrupt.</p>
<p >Set INT6 bit high, preserve other bits</p>
<pre class="fragment">    EIMSK |= ( 1 &lt;&lt; INT6 );
</pre>
</div>
</div>
<a id="a655e28b0ab1578b6bd258c87d2330716" name="a655e28b0ab1578b6bd258c87d2330716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655e28b0ab1578b6bd258c87d2330716">&#9670;&nbsp;</a></span>setupEncoder1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Encoders_c::setupEncoder1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >setupEncoder1 must be called before encoder 1 can be accessed (or nothing wil happen!).</p>
<p >The 3Pi+ Arduino board uses the pin PE2 (port E, pin 2) which is very unconventional. It doesn't have a standard arduino alias (like d6, or a5, for example). It is set up here with direct register access.</p>
<p >Writing a 0 to a DDRE (Data Direction Register (Port)E) sets as input.</p>
<p >Pin PE2 is required, which means bit 2 (counting from 0).</p>
<pre class="fragment">  PE Register bits [ 7  6  5  4  3  2  1  0 ]
  Binary mask      [ 1  1  1  1  1  0  1  1 ]
</pre><p> By performing an &amp; operation, the 0 sets low, all 1's preserve previous state.</p>
<p >Impementation of above:</p>
<pre class="fragment">  DDRE = DDRE &amp; ~(1&lt;&lt;DDE6);
</pre><p >Enable the pull up resistor for the pin. Once a pin is set up (as above), write a 1 to the bit in the output register.</p>
<pre class="fragment">  PORTE = PORTE | (1 &lt;&lt; PORTE2 );

  pinMode( ENCODER_1_A_PIN, INPUT );

  digitalWrite( ENCODER_1_A_PIN, HIGH ); // Encoder 1 xor
</pre><p >Initialise the recorded state of e1 encoder.</p>
<pre class="fragment">  state_e1 = 0;
</pre><p >Get initial state of encoder.</p>
<pre class="fragment">  boolean e1_B = PINE &amp; (1&lt;&lt;PINE2);
</pre><p >Standard read from the other pin.</p>
<pre class="fragment">   boolean e1_A = digitalRead( ENCODER_1_A_PIN ); // 26 the same as A8
</pre><p >Combine signals and perform XOR operation to restore true value:</p>
<pre class="fragment">   e1_A = e1_A ^ e1_B;
</pre><p >Shift values into correct place in state. Bits 1 and 0 are prior states.</p>
<pre class="fragment">      state_e1 = state_e1 | ( e1_B &lt;&lt; 1 );
      state_e1 = state_e1 | ( e1_A &lt;&lt; 0 );
</pre><p >Enable pin-change interrupt on A8 (PB4) for encoder0, and disable other pin-change interrupts. Note, this register will normally create an interrupt a change to any pins on the port, but we use PCMSK0 to set it only for PCINT4 which is A8 (PB4) When we set these registers, the compiler will now look for a routine called <a class="el" href="class_encoders__c.html#ac59863f4c577172e749340dcc5b2e9b2">ISR( PCINT0_vect )</a> when it detects a change on the pin. PCINT0 seems like a mismatch to PCINT4, however there is only the one vector servicing a change to all PCINT0-&gt;7 pins.</p>
<pre class="fragment">      PCICR = PCICR &amp; ~( 1 &lt;&lt; PCIE0 );
      PCMSK0 |= (1 &lt;&lt; PCINT4);
      PCIFR |= (1 &lt;&lt; PCIF0);
</pre><p >Finally, enable interrupt:</p>
<pre class="fragment">     PCICR |= (1 &lt;&lt; PCIE0);
</pre>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/TB PHASE/Physical_Robot_Experiment/Robots/PiControl/PiControl/encoders.c</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_encoders__c.html">Encoders_c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
